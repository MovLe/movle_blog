---
title: '[数据结构与算法]-数据结构与算法(8)-排序'
date: 2019-01-23 18:00:00
tags: 
- 数据结构
- 算法
categories: 数据结构与算法
---


### 一.排序的基本概念与分类
#### 1.定义：
##### (1)排序：
假设含有n个记录的序列为{r<sub>1</sub>,r<sub>2</sub>,......,r<sub>n</sub>}，其相应的关键字分别为{k<sub>1</sub>,k<sub>2</sub>,......,k<sub>n</sub>}，需确定1,2,......,n的一种排列p<sub>1</sub>,p<sub>2</sub>,......,p<sub>n</sub>，使其相应的关键字满足k<sub>p1</sub>≤k<sub>p2</sub>≤......≤k<sub>pn</sub>(非递减或非递增)关系，即使得序列成为一个按关键字有序的序列{r<sub>p1</sub>,r<sub>p2</sub>,......,r<sub>pn</sub>}，这样的操作就称为排序
<sub></sub>
#### 2.排序的稳定性：
(1)假设k<sub>i</sub>=k<sub>j</sub>(1≤i≤n,1≤j≤n,i≠j)，且在排序前的序列中r<sub>i</sub>领先于r<sub>j</sub>(即i<j)。如果排序后r<sub>i</sub>仍领先于r<sub>j</sub>，则称所用的排序方法是稳定的；反之，若可能使得排序后的序列中r<sub>j</sub>领先r<sub>i</sub>，则称所用的排序方法是不稳定的

#### 3.内排序与外排序
(1)内排序是在排序整个过程中，待排序的所有记录全部被放置在内存中

(2)外排序是由于排序的记录个数太多，不能同时放置在内存，整个排序过程需要在内外存之间多次交换数据才能进行

(3)对于内排序来说，排序算法的性能主要是受3个方面影响：

* 时间性能：高效率的内排序算法应该是具有尽可能少的关键字比较次数和尽可能少的记录移动次数 
* 辅助空间：评价排序算法的另一个主要标准是执行算法所需要的辅助存储空间。辅助存储空间是除了存放待排序所占用的存储空间之外，执行算法所需要的其他存储空间
* 算法的复杂性：这里指的是算法本身的复杂度，而不是指算法的时间复杂度

(4)内排序分为：插入排序、交换排序、选择排序和归并排序

![排序](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MzkxNDA3LTcxZThlMjAyODE3MmJiZTcucG5n?x-oss-process=image/format,png)

### 二.冒泡排序
#### 1.冒泡排序的基本思想：
冒泡排序（Bubble Sort）一种交换排序，它的基本思想是：两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止

#### 2.冒泡排序算法：

![冒泡排序图解1](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MzkxNDA3LTk3YTgxNjAxN2VkNzFiMWMucG5n?x-oss-process=image/format,png)

![冒泡排序图解2](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MzkxNDA3LTg5ODM3MDYwYjczMzAzZGYucG5n?x-oss-process=image/format,png)

#### 3.冒泡排序代码实现：
```
```
#### 4.冒泡排序优化

#### 5.冒泡排序复杂度：
冒泡排序的时间复杂度为O(n2)。

### 三.简单选择排序
#### 1.简单选择排序算法：
##### (1)定义：
简单选择排序法(Simple Selection Sort)就是通过n-i次关键字间的比较，从n-i＋1个记录中选出关键字最小的记录，并和第i(1≤i≤n)个记录交换之

##### (2)代码实现：
```
```
#### 2.简单选择排序复杂度分析：
(1)简单选择排序的“时间复杂度依然为O(n<sup>2</sup>)

(2)尽管与冒泡排序同为O(n2)，但简单选择排序的性能上还是要略优于冒泡排序

### 四.直接插入排序
#### 1.直接插入排序算法：
##### (1)定义：
直接插入排序（Straight Insertion Sort）的基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增1的有序表 

##### (2)代码实现：
```
```

#### 2.直接插入排序复杂度分析
(1)直接插入排序法的时间复杂度为O(n<sup>2</sup>)

(2)同样的O(n2)时间复杂度，直接插入排序法比冒泡和简单选择排序的性能要好一些

### 五.希尔排序
#### 1.希尔排序原理：
#### 2.希尔排序算法：
#### 3.希尔排序复杂度分析：

### 六.堆排序：
#### 1.定义：
##### (1)堆排序(HeapSort)，就是对简单选择排序进行的一种改进

##### (2)堆是具有下列性质的完全二叉树：

* 每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆(如图所示)；
* 或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆

![堆](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MzkxNDA3LTZlODM2ZGEzMGM1NjY4NDUucG5n?x-oss-process=image/format,png)

#### 2.堆排序算法：
##### (1)堆排序（Heap Sort）就是利用堆（假设利用大顶堆）进行排序的方法

##### (2)基本思想：
将待排序的序列构造成一个大顶堆。此时，整个序列的最大值就是堆顶的根结点。将它移走(其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值)，然后将剩余的n-1个序列重新构造成一个堆，这样就会得到n个元素中的次大值。如此反复执行，便能得到一个有序序列了

##### (3)代码实现：
```
```
#### 3.堆排序复杂度分析：
##### (1)堆排序的时间复杂度为O(nlogn)

### 七.归并排序：
#### 1.归并排序算法：
##### (1)归并排序（Merging Sort）就是利用归并的思想实现的排序方法

##### (2)原理：
它的原理是假设初始序列含有n个记录，则可以看成是n个有序的子序列，每个子序列的长度为1，然后两两归并，得到|n/2|（|x|表示不小于x的最小整数）个长度为2或1的有序子序列；再两两归并，……，如此重复，直至得到一个长度为n的有序序列为止，这种排序方法称为2路归并排序 

##### (3)代码实现：
```
```
#### 2.归并排序复杂度分析：
##### (1)归并排序的算法复杂度为O(nlogn)

###### 3.非递归实现归并排序：
##### (1)代码实现：

##### (2)使用归并排序时，尽量考虑用非递归方法

### 八.快速排序：
#### 1.含义：
(1)希尔排序相当于直接插入排序的升级，它们同属于插入排序类
(2)堆排序相当于简单选择排序的升级，它们同属于选择排序类。
(3)而快速排序其实就是冒泡排序的升级，它们都属于交换排序类

#### 2.快速排序算法：
##### (1)基本思想：
通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序的目的

##### (2)代码实现：

```
```

#### 3.快速排序复杂度分析：
##### (1)快速排序的算法复杂度为O(nlogn)

#### 4.快速排序的优化
(1)优化选取枢轴
(2)优化不必要的交换
(3)优化小数组时的排序方案
(4)优化递归操作：

### 九.总结：
#### 1.将内排序分为：插入排序、交换排序、选择排序和归并排序四类

![排序分类](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MzkxNDA3LWNmMjExOTMyNTk4ZjZhNzkucG5n?x-oss-process=image/format,png)

#### 2.排序算法复杂度：

![排序复杂度](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MzkxNDA3LWQ4NGQxMGFjNmM0YTU3MzkucG5n?x-oss-process=image/format,png)

#### 3.从算法的简单性来看，我们将7种算法分为两类：

* 简单算法：冒泡、简单选择、直接插入
* 改进算法：希尔、堆、归并、快速

(1)从平均情况来看，显然最后3种改进算法要胜过希尔排序，并远远胜过前3种简单算法。

(2)从最好情况看，反而冒泡和直接插入排序要更胜一筹，也就是说，如果你的待排序序列总是基本有序，反而不应该考虑4种复杂的改进算法。

(3)从最坏情况看，堆排序与归并排序又强过快速排序以及其他简单排序

(4)从稳定性来看，归并排序独占鳌头，对于非常在乎排序稳定性的应用中，归并排序是个好算法